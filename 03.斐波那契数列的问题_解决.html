<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title>title</title>
</head>

<body>
  <h2>斐波那契的问题--使用缓存解决</h2>
</body>

</html>
<script>
  // 自己封装的缓存
  function createCache() {
    // 最大的保存数量
    var maxCount = 2;
    // 保存键
    var keys = [];

    // 返回
    return function (key, value) {
      // 如果传入了 value 那么走保存逻辑
      if (value) {
        arguments.callee[key] = value;
        if (keys.push(key) > maxCount) {
          // 越界了 删除数组中的第一个
          delete arguments.callee[keys.shift()];
        }
      } // 否则 走读取的逻辑 
      else {
        return arguments.callee[key];
      }
    };
  }

  /*
    使用缓存优化的原则
      缓存中有--->直接用
      缓存中没有--->还是要计算
      计算出来的结果--->保存到 缓存中
  */
  // 创建缓存 
  var resultCache = createCache();
  var count = 0;
  // 返回斐波那契数列 第n项的值
  function result(n) {
    count++;
    // 从缓存中取一下
    // var num = resultCache[n];
    var num = resultCache(n);
    // 如果缓存中没有值
    if (!num) {
      if (n == 1 || n == 2) {
        // return 1;把返回改为 保存到 缓存中
        num = 1;
        // resultCache[n] = num;
      } else {
        num = result(n - 1) + result(n - 2);
        // resultCache[n] = num;
      }
      // resultCache[n] = num;
      // 调用我们自己提供的方法 进行 取值 赋值
      resultCache(n,num);
    }
    return num;
  }
  console.log(result(100));
  console.log('count:' + count);

  /*
    面试:
      1.软件缓存 -->播放器
      2.硬件缓存 -->内存(可选)
      3.我在学习jQuery源码时,发现-->实现了缓存
        4.原理--> 存到对象中,要用去缓存中找找,有->直接用 没有->存起来下次用
           -->长度的限制 50个
      5.自己试着实现了一下缓存
           为了保证封装性以及一定的访问性 ---闭包
      6.用它来解决一些性能问题
      7.之前我在使用递归实现斐波那契函数的时候 有很大性能消耗问题
      8.引入缓存之后 质的飞跃
  */ 
</script>